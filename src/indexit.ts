/* eslint-disable no-shadow */
/* eslint-disable no-unused-expressions */

import yargs from "yargs"

import { Options, TEST_TYPE } from "./types"
import { main } from "./main"


const IS_TESTING = process?.env?.NODE_ENV == "test"

if (!IS_TESTING) {
	indexit()
}

// TODO yarg's types properly

/**
 * Contains all the yargs related stuff for processing the raw cli arguments.
 * When used from the command line it is required by "./index.js" and since IS_TESTING will be false, indexit gets run.
 *
 * Otherwise when we're testing (or if we run this directly with the babel:run script) we can require this indexit function and run it directly to extract it's return (which is only created when testing.)
 */
export async function indexit(args?: string[]): Promise<void | string[][]> {
	// when testing, lets us return to the test what would normally be console.logged
	let test_return = { value: undefined }
	// record the promise main returns, because otherwise yargs won't wait for it
	let promise: Promise<void | string[][]>

	// Note: Doing yargs(args ? args : process.argv) won't work. Not 100% sure why.
	;(args ? yargs(args) : yargs)
		.scriptName("indexit")
		.usage("Usage: $0 <command> [options]")
		.demandCommand(1)
		.command(
			"update [globs...]",
			"create/update indexes",
			add_options as any,
			yargs => { promise = main({ testing: IS_TESTING, type: TEST_TYPE.UPDATE }, test_return)(yargs as any) },
		)
		.command(
			"test [globs...]",
			"print out the new contents of the indexes without touching the files",
			add_options as any,
			yargs => { promise = main({ testing: IS_TESTING, type: TEST_TYPE.TEST }, test_return)(yargs as any) },
		)
		.help()
		.argv

	yargs.parserConfiguration({
		"short-option-groups": false,
		"camel-case-expansion": false,
		"dot-notation": true,
		"parse-numbers": false,
		"boolean-negation": true,
	})
	if (promise!) await promise!

	if (test_return.value) return test_return.value
}

/** Adds shared options. */
function add_options(yargs: yargs.Argv<Options>) {
	yargs
		.positional("globs", {
			default: ["src/**", "src/"],
			description: `A series of globs to determine which folders to search in. Be default it searches src/** AND src/ (this is needed, otherwise we can't detect the "root" index).`,
		})
		.option("ignore", {
			alias: "i",
			type: "array",
			default: [],
			description: `A list of globs to ignore. If a file matches an ignored glob but it's parent folder doesn't, the index.js will still be "managed", but that file won't be exported.`,
		})
		.option("tag.start", {
			alias: "s",
			type: "string",
			default: "/* Autogenerated Index [OPTIONS] */",
			description: "Determines the start of the managed index. By default it's /* Autogenerated Index [OPTIONS] */. Use [OPTIONS], brackets included, to determine where you specify the way exports will be generated.",
		})
		.option("tag.end", {
			alias: "e",
			type: "string",
			default: "",
			description: "Determines the end of the managed index. If nothing is passed, it's assumed you want the end to be the end of the file.",
		})
		.option("force <extension>", {
			alias: "f",
			type: "string",
			default: false,
			description: "If files match the given glob but their is no sibling index file if this option is set to something (it should be set to the extension you want the generated indexes to have), the program will pretend there is one with the default options.",
		})
		.option("extensions", {
			alias: "x",
			type: "array",
			default: ["ts", "js"],
			description: "Array of extensions files can be. By default both typescript and javascript files are included: ts, js. The order defines which file to use if there are two files with the same name.",
		})
}
