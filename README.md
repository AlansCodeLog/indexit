Indexit is a small cli app for managing javascript and/or typescript index files.

Anywhere you want an index file to be managed you add the comment `/* Autogenerated Index */` and from there to the end of the file, the program can do it's thing (exports will be exported alphabetically by their "name").

Then you can run `indexit test` (this is the equivalent of running `indexit test src/** src/`) to see a preview of the indexes it would write to and what would be written.

You can list as many globs as you want: `indexit test glob1/** glob2/** glob3/**`.

# Notes
- If you get no results note that you must use forward slashes `/` for file paths in the glob. Backslashes are only for escaping characters.**
- If you want the indexes at, for example, `glob1` (`glob1/index.js`) to be allowed to be written to you must also add `glob1/` to the globs, otherwise it won't work. This is why the default is `src/** src/`.
- The `node_modules` directory is always ignored.

To actually write the changes run `indexit update` with the options you tested.

**IMPORTANT!: git add/commit your changes before running or double check the test output thoroughly.**

You can find a good example of how things get exported in the [tests/fixtures folder](./tests/fixtures), the `index.expected.ts` files are what would be written.

# The Header

The section the app is allowed to modify can be managed with the flags `--tag.start` and `--tag.end`. Note that the tag start must look something like: `/* Autogenerated Index [OPTIONS] */`, so we can extract any options from the index files.

Note: It is assumed you will want `/* Autogenerated Index */` to match as well even though it's missing the extra space where we remove the `[OPTIONS]` part, so spaces after that bit are allowed.

## Options

The options bit of the header allows you to specify how that index file will be exported.

By default we take `/* Autogenerated Index */` to mean `/* Autogenerated Index [Named]*/` since if we took it to mean the options were empty, nothing would be generated.

To force pass no options you would do: `/* Autogenerated Index [] */`.

To pass multiple options, just separate them with a coma: `/* Autogenerated Index [Named, Default] */`

Note: Options are case insensitive.

## Possible Options and Implications

All the options: `Named`, `Default`, `Ignore`

### Named and Default

These two options determine exports are generated and how that files is re-exported as a folder if it is.

Note that named exports won't always create exports that look like: `export {named} from "..."`.

For example, since es6 doesn't allow doing something like `export * as foldername from "./foldername"`, instead we do:

```ts
import * as _foldername from "./foldername"
export const foldername = _foldername
```

And if it contains an export default, e.g. `export default { module1, module2 }`, then we can export it directly like: `export foldername from "./foldername"`.

In cases where both named and export default statements are found, both types of exports are used, but **note some exports will also need to be imported**. For example, normally you might have:

```ts
export { sibling_named } from "./sibling_named"
```

But it isn't possible to do this if you want it in the default exports as well:
```ts
export { sibling_named } from "./sibling_named"
export default {
	sibling_named // this doesn't exist
}
```
So we must do:
```ts
import { sibling_named } from "./sibling_named"
export { sibling_named } from "./sibling_named"
export default {
	sibling_named
}
```
### Ignore

Occasionally you might not want a nested folder to get re-exported in it's parent:

```
root/src
└──helpers
	└── x
```

For example, say we divided our helpers into different folders. You wouldn't want to import a function from `x` through `helpers`, since it can't be tree shaken (afaik) because helpers re-exports the entirety of `x` (regardless of it's export type).

If `x` uses the `Ignore` option, helpers won't re-export it.

# How it Works

After an index file with a header is found, it looks at all sibling files:

If the sibling contains a string like `export function/const/let`, it is assumed you want a named export, e.g. `export {name} from "./filename"`.

If the sibling contains the string `export default`, we try to look for the name of the export (e.g. `export default some_var`) to export it like `export some_var from "./filename"`, otherwise if there's an anonymous function (e.g.`export default function() {}`) we use the file name: `export filename from "./filename"`

If the sibling is a folder with an index file and it contains any `export function/const/let` statements, it is assumed you want to re-export them all using the folder's name as the name.

Note how everything has a "name" one way or another. This is what is used to sort the exports by.

# Other

I have taken care that `async`, typescript generic function names, and weird characters in function names are correctly identified, though there might still be more cases that don't work.

Currently the following regex is used to extract the portion with the name: https://regexr.com/4s9ol (you can see the names by using the list and inputting `$2\n`).

# Todos

- [ ] Error Handling if we can't write file.
- [ ] Warn when an index file matches a glob but no tag was detected.
- [ ] Option when using test to only print out the parts between the start/end tags.
